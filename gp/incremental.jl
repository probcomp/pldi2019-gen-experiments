include("cov_tree.jl")

# Model.

"""
Data type used in return value of the production kernel (V).
"""
struct NodeTypeAndXs
    node_type::Int
    xs::Vector{Float64}
end

"""
Data type for the return value of the aggregation kernel (W)
"""
struct CovFnAndMatrix
    node::Node
    cov_matrix::Matrix{Float64}
end

@gen function production_kernel(xs::Vector{Float64})
    node_type = @trace(categorical(node_dist), :type)

    # To be passed to the corresponding aggregation kernel application.
    v = NodeTypeAndXs(node_type, xs)

    # Elements to be passed to each child production kernel application.
    num_children = node_type_to_num_children[node_type]
    us = fill(xs, num_children)

    result = Production(v, us)
    return result
end

@gen function aggregation_kernel(
        node_type_and_xs::NodeTypeAndXs,
        child_outputs::Vector{CovFnAndMatrix})

    node_type::Int = node_type_and_xs.node_type
    xs::Vector{Float64} = node_type_and_xs.xs
    local node::Node
    local cov_matrix::Matrix{Float64}

    # constant kernel
    if node_type == CONSTANT
        @assert length(child_outputs) == 0
        param = @trace(uniform_continuous(0, 1), :param)
        node = Constant(param)
        cov_matrix = eval_cov_mat(node, xs)

    # linear kernel
    elseif node_type == LINEAR
        @assert length(child_outputs) == 0
        param = @trace(uniform_continuous(0, 1), :param)
        node = Linear(param)
        cov_matrix = eval_cov_mat(node, xs)

    # squared exponential kernel
    elseif node_type == SQUARED_EXP
        @assert length(child_outputs) == 0
        length_scale = @trace(uniform_continuous(0, 1), :length_scale)
        node = SquaredExponential(length_scale)
        cov_matrix = eval_cov_mat(node, xs)

    # periodic kernel
    elseif node_type == PERIODIC
        @assert length(child_outputs) == 0
        scale = @trace(uniform_continuous(0, 1), :scale)
        period = @trace(uniform_continuous(0, 1), :period)
        node = Periodic(scale, period)
        cov_matrix = eval_cov_mat(node, xs)

    # plus combinator
    elseif node_type == PLUS
        @assert length(child_outputs) == 2
        node = Plus(child_outputs[1].node, child_outputs[2].node)
        cov_matrix = child_outputs[1].cov_matrix .+ child_outputs[2].cov_matrix

    # times combinator
    elseif node_type == TIMES
        @assert length(child_outputs) == 2
        node = Times(child_outputs[1].node, child_outputs[2].node)
        cov_matrix = child_outputs[1].cov_matrix .* child_outputs[2].cov_matrix

    else
        error("unknown node type $(node_type)")
    end

    # to be passed to the parent aggregation kernel application
    w = CovFnAndMatrix(node, cov_matrix)

    return w
end

const covariance_prior = Recurse(
        production_kernel, aggregation_kernel,
        MAX_BRANCH,         # maximum number of children generated by production
        Vector{Float64},    # U (passed from production to its children)
        NodeTypeAndXs,      # V (passed from production to aggregation)
        CovFnAndMatrix)     # W (passed from aggregation to its parents, also Recurse's return type)

@gen (static) function model(xs::Vector{Float64})

    # sample covariance matrix
    cov_fn_and_matrix = @trace(covariance_prior(xs, 1), :tree)

    # sample diagonal noise
    noise = @trace(gamma(1, 1), :noise)

    # compute covariance matrix
    n = length(xs)
    cov_matrix = cov_fn_and_matrix.cov_matrix + Matrix((noise+ 0.01) * LinearAlgebra.I, n, n)

    # sample from multivariate normal
    @trace(mvnormal(zeros(n), cov_matrix), :ys)

    cov_fn = cov_fn_and_matrix.node
    return cov_fn
end

Gen.load_generated_functions()


# Proposals and inference.

@gen function subtree_proposal_recursive(cur::Int)

    # base address for production kernel application 'cur'
    prod_addr = (cur, Val(:production))

    # base address for aggregation kernel application 'cur'
    agg_addr = (cur, Val(:aggregation))

    # sample node type
    node_type = @trace(categorical(node_dist), prod_addr => :type)

    # constant kernel
    if node_type == CONSTANT
        @trace(uniform_continuous(0, 1), agg_addr => :param)

    # linear kernel
    elseif node_type == LINEAR
        @trace(uniform_continuous(0, 1), agg_addr => :param)

    # squared exponential kernel
    elseif node_type == SQUARED_EXP
        @trace(uniform_continuous(0, 1), agg_addr => :length_scale)

    # periodic kernel
    elseif node_type == PERIODIC
        @trace(uniform_continuous(0, 1), agg_addr => :scale)
        @trace(uniform_continuous(0, 1), agg_addr => :period)

    # plus combinator or times combinator
    elseif node_type == PLUS || node_type == TIMES
        child1 = get_child(cur, 1, MAX_BRANCH)
        child2 = get_child(cur, 2, MAX_BRANCH)
        @trace(subtree_proposal_recursive(child1))
        @trace(subtree_proposal_recursive(child2))

    # unknown node type
    else
        error("Unknown node type: $(node_type)")
    end

end


@gen function random_node_path_biased(cur::Int, node::Node)
    p_stop = isa(node, LeafNode) ? 1.0 : 0.5
    if @trace(bernoulli(p_stop), :stop)
        return cur
    else
        if @trace(bernoulli(0.5), :left)
            next_node = node.left
            child = get_child(cur, 1, MAX_BRANCH)
        else
            next_node = node.right
            child = get_child(cur, 2, MAX_BRANCH)
        end
        return @trace(random_node_path_biased(child, next_node), :rest_of_path)
    end
end

@gen function random_node_path_unbiased(cur::Int, node::Node)
    p_stop = isa(node, LeafNode) ? 1.0 : 1/size(node)
    if @trace(bernoulli(p_stop), :stop)
        return cur
    else
        p_left = size(node.left) / (size(node) - 1)
        if @trace(bernoulli(p_left), :left)
            next_node = node.left
            child = get_child(cur, 1, MAX_BRANCH)
        else
            next_node = node.right
            child = get_child(cur, 2, MAX_BRANCH)
        end
        return @trace(random_node_path_biased(child, next_node), :rest_of_path)
    end
end


@gen function random_node_path_root(cur::Int, node::Node)
    return 1
end

@gen function regen_random_subtree(prev_trace)
    prev_subtree_node = get_retval(prev_trace)
    subtree_idx = @trace(random_node_path_unbiased(1, prev_subtree_node), :path)
    @trace(subtree_proposal_recursive(subtree_idx), :subtree)
    return nothing
end

function subtree_involution(trace, fwd_choices::ChoiceMap, fwd_retval::Nothing, proposal_args::Tuple)
    model_args = get_args(trace)

    # populate constraints
    constraints = choicemap()
    set_submap!(constraints, :tree, get_submap(fwd_choices, :subtree))

    # obtain new trace and discard, which contains the previous subtree
    (new_trace, weight, _, discard) = update(trace, model_args, (NoChange(),), constraints)

    # populate backward assignment
    bwd_choices = choicemap()
    set_submap!(bwd_choices, :path, get_submap(fwd_choices, :path))
    # set_submap!(bwd_choices, :subtree, discard)
    set_submap!(bwd_choices, :subtree, get_submap(discard, :tree))

    (new_trace, bwd_choices, weight)
end

@gen function noise_proposal(prev_trace)
    @trace(gamma(1, 1), :noise)
end

function run_mcmc(trace, iters::Int)
    for iter=1:iters
        (trace, accept) = mh(trace, regen_random_subtree, (), subtree_involution)
        (trace, _) = mh(trace, select(:noise))
    end
    return trace
end

# Initialize trace and extract variables.

function initialize_trace(xs::Vector{Float64}, ys::Vector{Float64})
    constraints = choicemap()
    constraints[:ys] = ys
    (trace, _) = generate(model, (xs,), constraints)
    return trace
end

function extract_cov_noise(trace)
    cov = get_retval(trace)
    noise = trace[:noise] + 0.01
    return (cov, noise)
end
